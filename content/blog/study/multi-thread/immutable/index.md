---
title: Immutable - 망가뜨리고 싶어도 망가지지 않는다.
date: "2020-09-21T00:02:00.121Z"
description: "Hello World"
---

## Java 언어로 배우는 디자인 패턴 입문 - Immutable

- 불변성을 보장한다.
- 인스턴스가 생성된 후에는 내부 상태가 절대로 변하지 않는 클래스
- 여러개의 스레드가 동시에 엑세스 해도 무방
- Synchronized로 보호 할 필요 없다. 안전성과 생존성을 잃어버리지 않고 빠른 속도로 실행 할 수 있다.
- 인스턴스 상태가 절대 변하지 않기 때문에 인스턴스에 접근하기 위해 걸리는 배타 제어가 불필요하다. → 속도가 빠르다.
    - 클래스 내부에 외부에서 생성 이후 변경할 수 있는 방법을 제공하지 않는다면, 동시에 여러 스레드가 실행해도 Thread safe 하다고 볼 수 있다.
    - final class, private member는 불변 클래스의 필수 조건은 아니지만, 값이 변경 되는것을 막는 예방 조치로 볼 수 있다.
- 인스턴스의 상태가 절대 변하지 않음을 보장 할 수 있다면, synchronized로 보호 할 필요는 없다.
    - Critical section을 사용해서 Single Thread Execution을 적용할 필요 X
- 언제 Immutable 패턴을 적용 할 수 있을까?
    - 인스턴스 생성 후 상태가 변하지 않을때
        - 필드가 final로 선언돼 있고, setter 메소드가 존재 하지 않아야 한다.
            - **주의) 인스턴스 내 필드값 자체는 변하지 않더라도 필드가 참조하고 잇는 곳의 인스턴스가 변할 수  있다.**

    - 여러개의 스레드에서 하나의 인스턴스 참조를 가지고 빈번하게 접근할 가능성이 있을 때

- Java에서 Immutable vs Mutable 구현 예시
    - Immutable
        - java.lang.String
        - java.math.BigInteger
        - java.util.regex.Pattern
        - java.lang.Integer
    - Mutable
        - java.lang.StringBuffer
- 불변성을 지키기 위해서 재사용은 잘 고려해야한다.
    - 필드가 보유하고 있는 인스턴스를 그대로 getter 메소드의 반환 값으로 사용할 경우
        - 외부에서 getter를 통해 내부 인스턴스가 가리키고 있는 다른 인스턴스를 제어 할 수 있는 가능성이 있다.
    - 생성자에게 인수로 건낸 인스턴스를 그대로 필드에 대입
        - 생성자의 인수로 주어진 인스턴스는 외부에서 만들어진 것이다. 이 생성자를 호출한 누군가는 생성자에 전달된 인스턴스의 참조를 가지고 있을텐데, 그 인스턴스의 내부 상태가 변할 가능성이 있다.
        - 주어진 인스턴스를 그대로 대입해서 사용하지 않고, 전달받은 인스턴스와 같은 내용의 새로운 인스턴스를 생성해서 필드에 대입해서 사용하는 방법으로 해결한다.