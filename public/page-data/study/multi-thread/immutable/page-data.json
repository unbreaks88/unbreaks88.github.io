{"componentChunkName":"component---src-templates-blog-post-js","path":"/study/multi-thread/immutable/","result":{"data":{"site":{"siteMetadata":{"title":"기억을 기록하는 공간"}},"markdownRemark":{"id":"14b8c075-8612-522f-8f89-01a932b32667","excerpt":"Java 언어로 배우는 디자인 패턴 입문 - Immutable 불변성을 보장한다. 인스턴스가 생성된 후에는 내부 상태가 절대로 변하지 않는 클래스 여러개의 스레드가 동시에 엑세스 해도 무방 Synchronized…","html":"<h2>Java 언어로 배우는 디자인 패턴 입문 - Immutable</h2>\n<ul>\n<li>불변성을 보장한다.</li>\n<li>인스턴스가 생성된 후에는 내부 상태가 절대로 변하지 않는 클래스</li>\n<li>여러개의 스레드가 동시에 엑세스 해도 무방</li>\n<li>Synchronized로 보호 할 필요 없다. 안전성과 생존성을 잃어버리지 않고 빠른 속도로 실행 할 수 있다.</li>\n<li>\n<p>인스턴스 상태가 절대 변하지 않기 때문에 인스턴스에 접근하기 위해 걸리는 배타 제어가 불필요하다. → 속도가 빠르다.</p>\n<ul>\n<li>클래스 내부에 외부에서 생성 이후 변경할 수 있는 방법을 제공하지 않는다면, 동시에 여러 스레드가 실행해도 Thread safe 하다고 볼 수 있다.</li>\n<li>final class, private member는 불변 클래스의 필수 조건은 아니지만, 값이 변경 되는것을 막는 예방 조치로 볼 수 있다.</li>\n</ul>\n</li>\n<li>\n<p>인스턴스의 상태가 절대 변하지 않음을 보장 할 수 있다면, synchronized로 보호 할 필요는 없다.</p>\n<ul>\n<li>Critical section을 사용해서 Single Thread Execution을 적용할 필요 X</li>\n</ul>\n</li>\n<li>\n<p>언제 Immutable 패턴을 적용 할 수 있을까?</p>\n<ul>\n<li>\n<p>인스턴스 생성 후 상태가 변하지 않을때</p>\n<ul>\n<li>\n<p>필드가 final로 선언돼 있고, setter 메소드가 존재 하지 않아야 한다.</p>\n<ul>\n<li><strong>주의) 인스턴스 내 필드값 자체는 변하지 않더라도 필드가 참조하고 잇는 곳의 인스턴스가 변할 수  있다.</strong></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>여러개의 스레드에서 하나의 인스턴스 참조를 가지고 빈번하게 접근할 가능성이 있을 때</li>\n</ul>\n</li>\n<li>\n<p>Java에서 Immutable vs Mutable 구현 예시</p>\n<ul>\n<li>\n<p>Immutable</p>\n<ul>\n<li>java.lang.String</li>\n<li>java.math.BigInteger</li>\n<li>java.util.regex.Pattern</li>\n<li>java.lang.Integer</li>\n</ul>\n</li>\n<li>\n<p>Mutable</p>\n<ul>\n<li>java.lang.StringBuffer</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>불변성을 지키기 위해서 재사용은 잘 고려해야한다.</p>\n<ul>\n<li>\n<p>필드가 보유하고 있는 인스턴스를 그대로 getter 메소드의 반환 값으로 사용할 경우</p>\n<ul>\n<li>외부에서 getter를 통해 내부 인스턴스가 가리키고 있는 다른 인스턴스를 제어 할 수 있는 가능성이 있다.</li>\n</ul>\n</li>\n<li>\n<p>생성자에게 인수로 건낸 인스턴스를 그대로 필드에 대입</p>\n<ul>\n<li>생성자의 인수로 주어진 인스턴스는 외부에서 만들어진 것이다. 이 생성자를 호출한 누군가는 생성자에 전달된 인스턴스의 참조를 가지고 있을텐데, 그 인스턴스의 내부 상태가 변할 가능성이 있다.</li>\n<li>주어진 인스턴스를 그대로 대입해서 사용하지 않고, 전달받은 인스턴스와 같은 내용의 새로운 인스턴스를 생성해서 필드에 대입해서 사용하는 방법으로 해결한다.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>","frontmatter":{"title":"Immutable - 망가뜨리고 싶어도 망가지지 않는다.","date":"September 21, 2020","description":"Hello World"}}},"pageContext":{"slug":"/study/multi-thread/immutable/","previous":{"fields":{"slug":"/new-beginnings/"},"frontmatter":{"title":"New Beginnings"}},"next":null}},"staticQueryHashes":["1246554614","2841359383"]}